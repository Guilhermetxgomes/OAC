$date
	Mon Dec  2 15:09:19 2024
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module fetch_tb $end
$var wire 32 ! pc_out [31:0] $end
$var wire 32 " instrucao [31:0] $end
$var reg 1 # clock $end
$var reg 1 $ if_flush $end
$var reg 1 % load_if_id_register $end
$var reg 1 & load_pc $end
$var reg 1 ' mux_sel $end
$var reg 32 ( pc_branch_value [31:0] $end
$var reg 1 ) reset $end
$scope module uut $end
$var wire 1 # clock $end
$var wire 1 $ if_flush $end
$var wire 1 % load_if_id_register $end
$var wire 1 & load_pc $end
$var wire 1 ' mux_sel $end
$var wire 32 * pc_branch_value [31:0] $end
$var wire 1 ) reset $end
$var wire 32 + pc_out_interno [31:0] $end
$var wire 32 , pc_out [31:0] $end
$var wire 32 - pc_in_interno [31:0] $end
$var wire 32 . instrucao_interno [31:0] $end
$var wire 32 / instrucao [31:0] $end
$scope module if_id_register $end
$var wire 1 # clock $end
$var wire 1 $ if_flush $end
$var wire 32 0 instruction [31:0] $end
$var wire 1 % load $end
$var wire 32 1 pc_out [31:0] $end
$var wire 1 ) reset $end
$var wire 32 2 pc_in [31:0] $end
$var wire 32 3 instruction_memory_in [31:0] $end
$var reg 32 4 im_value [31:0] $end
$var reg 32 5 pc_value [31:0] $end
$upscope $end
$scope module im $end
$var wire 32 6 addr [31:0] $end
$var reg 32 7 instr [31:0] $end
$upscope $end
$scope module mux_instruction_fetch $end
$var wire 32 8 D0 [31:0] $end
$var wire 32 9 D1 [31:0] $end
$var wire 1 ' sel $end
$var wire 32 : D_out [31:0] $end
$var parameter 32 ; WIDTH $end
$upscope $end
$scope module pc $end
$var wire 1 # clock $end
$var wire 1 & load $end
$var wire 32 < pc_in [31:0] $end
$var wire 1 ) reset $end
$var wire 32 = pc_out [31:0] $end
$var reg 32 > pc_value [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b100000 ;
$end
#0
$dumpvars
bx >
bx =
bx <
bx :
b0 9
bx 8
bx 7
bx 6
bx 5
bx 4
bx 3
bx 2
bx 1
bx 0
bx /
bx .
bx -
bx ,
bx +
b0 *
1)
b0 (
0'
0&
0%
0$
0#
bx "
bx !
$end
#5
b100 -
b100 2
b100 :
b100 <
b100001010000100000011 .
b100001010000100000011 3
b100001010000100000011 7
b100 8
b0 +
b0 6
b0 =
b0 >
b0 "
b0 /
b0 0
b0 4
b0 !
b0 ,
b0 1
b0 5
1#
#10
0#
1%
1&
0)
#15
b1000 -
b1000 2
b1000 :
b1000 <
b1000010010000010100011 .
b1000010010000010100011 3
b1000010010000010100011 7
b100001010000100000011 "
b100001010000100000011 /
b100001010000100000011 0
b100001010000100000011 4
b100 !
b100 ,
b100 1
b100 5
b1000 8
b100 +
b100 6
b100 =
b100 >
1#
#20
b10000 -
b10000 2
b10000 :
b10000 <
0#
b10000 (
b10000 *
b10000 9
1'
#25
b1000011111001100110011 .
b1000011111001100110011 3
b1000011111001100110011 7
b10100 8
b10000 +
b10000 6
b10000 =
b10000 >
b1000010010000010100011 "
b1000010010000010100011 /
b1000010010000010100011 0
b1000010010000010100011 4
b10000 !
b10000 ,
b10000 1
b10000 5
1#
#30
0#
1$
#35
b0 "
b0 /
b0 0
b0 4
b0 !
b0 ,
b0 1
b0 5
1#
#40
b10100 -
b10100 2
b10100 :
b10100 <
0#
0'
0$
#45
b11000 -
b11000 2
b11000 :
b11000 <
b1000011110001110110011 .
b1000011110001110110011 3
b1000011110001110110011 7
b11000 8
b10100 +
b10100 6
b10100 =
b10100 >
b1000011111001100110011 "
b1000011111001100110011 /
b1000011111001100110011 0
b1000011111001100110011 4
b10100 !
b10100 ,
b10100 1
b10100 5
1#
#50
0#
#55
b11100 -
b11100 2
b11100 :
b11100 <
b10100100000000011100011 .
b10100100000000011100011 3
b10100100000000011100011 7
b1000011110001110110011 "
b1000011110001110110011 /
b1000011110001110110011 0
b1000011110001110110011 4
b11000 !
b11000 ,
b11000 1
b11000 5
b11100 8
b11000 +
b11000 6
b11000 =
b11000 >
1#
#60
0#
